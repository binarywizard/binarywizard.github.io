# 问题汇总

1. uuid 是否有重复？
   - 自动 id 生成策略
   - 分布式 id 生成原理
2. 线程池
3. 前 10 个 ip，内存不足

## 项目

1. Storm/Flink 消息有序性保证
2. 蓄洪机制原理
3. storm-jms 模块修改
4. ugc 视频生产优化
5. 工作流引擎原理
6. MySQL 分库分表原因
7. 推荐机制
8. Neo4j 原理，社区版和商业版，对比其他图数据库

## Spring

1. Hibernate 优缺点，Mybatis 优缺点，为什么都用 Mybatis？
2. Spring 启动过程？
3. Bean 加载过程
4. AOP 原理（字节码层面）
5. 循环依赖
6. Spring Boot 自动注入配置原理过程
7. 事务传播级别
8. Spring Interceptor 机制，以及和 filter 区别关系？

## RPC 框架

1. 设计一个 RPC 框架
2. RPC 框架通讯协议
3. 常见 RPC 框架，优缺点，原理

## 网络

1. 三次握手，四次挥手，包括状态变化
2. 拥塞
3. 滑动窗口
4. MTU/MSS
5. 可靠性如何保证
6. HTTP(S)协议，HTTP1/2

## Java

1. HashMap 原理
2. 多线程编程，CountLatch、CyclicBarrier
3. Volatile/Synchronized
4. 可重入锁、自旋锁、偏向锁、轻量级锁
5. 多线程环境下单例的两种实现（effective java)，以及 volatile 存在的意义
6. 线程池原理
7. 实现简单的线程池
8. 多路复用 IO 为何比非阻塞 IO 的效率更高？
   - 非阻塞 IO 中，不断地询问 socket 状态是通过用户线程进行的，在多路复用 IO 中，轮训每个 socket 状态是内核中进行的，效率要比用户线程要高
9. Java IO/NIO
   - 阻塞 IO
   - 非阻塞 IO
   - 多路复用 IO
   - 信号驱动 IO
   - 异步 IO
     - 只需先发送一个请求，当接收内核返回的成功信号时表示 IO 操作已经完成，可以直接去使用数据
10. Java NIO

- 三大核心：Channel, Buffer, Selector
- IO 是面向流的，NIO 是面向缓冲区的

## JVM

1. 运行时数据区划分
2. 垃圾回收
3. 类加载过程
4. 栈帧
   - 一个线程中，每调用一个方法创建一个栈帧
   - 栈帧结构
     - 本地变量表
     - 操作数栈
     - 动态链接
     - 方法出口
5. 内存溢出和内存泄漏的区别
6. StackOverFlow 和 OutOfMemory 区别
7. 对象从新生代移到老年代的条件
8. Java8 中永久代被移出，由元空间取代，使用本地内存，字符串池和类的静态变量放入 java 堆中
9. GC Roots 有哪些？
   - VM 栈中的引用
   - 方法区中的静态变量
   - JNI 中的引用
10. 垃圾收集算法
    - 标记清除
      - 内存碎片化严重
    - 复制
      - 可用内存被压缩到一半，如果存活对象增多，效率会低
    - 标记整理
    - 分代收集
11. 垃圾收集器
    - Serial
      - 新生代，复制算法，单个 CPU 环境
    - ParNew
      - 新生代，复制算法，Serial 的多线程版本
    - Parallel Scavenge
      - 新生代，复制算法，多线程
      - 可控制的吞吐量，CPU 运行用户代码的时间/CPU 总消耗时间
      - 自适应调节策略
    - Serial Old
      - Serial 的老年代版本，单线程，标记整理算法
      - CMS 的后备方案
    - Parallel Old
      - Parallel Scavenge 的年老代版本，多线程，标记整理算法
    - CMS
      - 多线程，标记清除算法
      - 初始标记、并发标记、重新标记、并发清除
    - G1
      - 标记整理，无内存碎片，低停顿
      - 区域划分、优先级区域回收

## 排序算法

1. 快排

## 算法

### 图

1. 路径查找

### 树

1. 红黑树

## Effective Java

## 分布式

1. 分布式事务
2. 分布式锁

## 数据库

1. 聚簇索引和非聚簇索引
2. 主键索引和联合索引
